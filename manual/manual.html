<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>CN Manual (draft, to be expanded)</title>
  <style>
html {
font-family: sans-serif;
font-size: 20px;
line-height: 1.4;
color: #1a1a1a;
background-color: #fdfdfd;
}
body {
margin: 0 auto;
max-width: 45em;
padding-left: 50px;
padding-right: 50px;
padding-top: 50px;
padding-bottom: 50px;
hyphens: auto;
overflow-wrap: break-word;
text-rendering: optimizeLegibility;
font-kerning: normal;
}
@media (max-width: 600px) {
body {
font-size: 0.9em;
padding: 12px;
}
h1 {
font-size: 1.8em;
}
}
@media print {
html {
background-color: white;
}
body {
background-color: transparent;
color: black;
font-size: 12pt;
}
p, h2, h3 {
orphans: 3;
widows: 3;
}
h2, h3, h4 {
page-break-after: avoid;
}
}
p {
margin: 1em 0;
}
a {
color: #1a1a1a;
}
a:visited {
color: #1a1a1a;
}
img {
max-width: 100%;
}
svg {
height: auto;
max-width: 100%;
}
h1, h2, h3, h4, h5, h6 {
margin-top: 1.4em;
}
h5, h6 {
font-size: 1em;
font-style: italic;
}
h6 {
font-weight: normal;
}
ol, ul {
padding-left: 1.7em;
margin-top: 1em;
}
li > ol, li > ul {
margin-top: 0;
}
blockquote {
margin: 1em 0 1em 1.7em;
padding-left: 1em;
border-left: 2px solid #e6e6e6;
color: #606060;
}
code {
font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
font-size: 85%;
margin: 0;
hyphens: manual;
}
pre {
margin: 1em 0;
overflow: auto;
}
pre code {
padding: 0;
overflow: visible;
overflow-wrap: normal;
}
.sourceCode {
background-color: transparent;
overflow: visible;
}
hr {
background-color: #1a1a1a;
border: none;
height: 1px;
margin: 1em 0;
}
table {
margin: 1em 0;
border-collapse: collapse;
width: 100%;
overflow-x: auto;
display: block;
font-variant-numeric: lining-nums tabular-nums;
}
table caption {
margin-bottom: 0.75em;
}
tbody {
margin-top: 0.5em;
border-top: 1px solid #1a1a1a;
border-bottom: 1px solid #1a1a1a;
}
th {
border-top: 1px solid #1a1a1a;
padding: 0.25em 0.5em 0.25em 0.5em;
}
td {
padding: 0.125em 0.5em 0.25em 0.5em;
}
header {
margin-bottom: 4em;
text-align: center;
}
#TOC li {
list-style: none;
}
#TOC ul {
padding-left: 1.3em;
}
#TOC > ul {
padding-left: 0;
}
#TOC a:not(:hover) {
text-decoration: none;
}
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}

ul.task-list[class]{list-style: none;}
ul.task-list li input[type="checkbox"] {
font-size: inherit;
width: 0.8em;
margin: 0 0.8em 0.2em -1.6em;
vertical-align: middle;
}
.display.math{display: block; text-align: center; margin: 0.5rem auto;}

pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ background-color: #f8f8f8; }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ef2929; } 
code span.an { color: #8f5902; font-weight: bold; font-style: italic; } 
code span.at { color: #204a87; } 
code span.bn { color: #0000cf; } 
code span.cf { color: #204a87; font-weight: bold; } 
code span.ch { color: #4e9a06; } 
code span.cn { color: #8f5902; } 
code span.co { color: #8f5902; font-style: italic; } 
code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } 
code span.do { color: #8f5902; font-weight: bold; font-style: italic; } 
code span.dt { color: #204a87; } 
code span.dv { color: #0000cf; } 
code span.er { color: #a40000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #0000cf; } 
code span.fu { color: #204a87; font-weight: bold; } 
code span.im { } 
code span.in { color: #8f5902; font-weight: bold; font-style: italic; } 
code span.kw { color: #204a87; font-weight: bold; } 
code span.op { color: #ce5c00; font-weight: bold; } 
code span.ot { color: #8f5902; } 
code span.pp { color: #8f5902; font-style: italic; } 
code span.sc { color: #ce5c00; font-weight: bold; } 
code span.ss { color: #4e9a06; } 
code span.st { color: #4e9a06; } 
code span.va { color: #000000; } 
code span.vs { color: #4e9a06; } 
code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } 
</style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">CN Manual (draft, to be expanded)</h1>
</header>
<!-- section 'Annotation syntax' copied and adjusted from 2021-10-cn-report -->
<h2 id="cn-language">CN language</h2>
<p>CN includes several different kinds of annotations for different
purposes. Primarily, users write type specifications for functions and
loops. In order to phrase these specifications, users may define
(mutually) inductive datatypes, specification functions, and resource
predicates. Finally, where verification requires reasoning steps outside
the fragment handled by CN’s proof automation, users assist in the
proof, by inserting CN ghost statements, or by manually stating and
applying lemmata required for the verification. The following gives an
overview of each of these CN sub-languages. The full grammar is given in
section “Grammar”.</p>
<h3 id="type-specifications">Type specifications</h3>
<p>Function and loop types are specified as “magic comments” of the form
<code>/*@ ... @*/</code> in the C code.</p>
<h4 id="function-types">Function types</h4>
<p>In the case of function definitions the magic comment is placed after
the argument list, before the function body block:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> f<span class="op">(...</span>args<span class="op">...)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">/*@ &lt;function_spec&gt; @*/</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span>body of f<span class="op">...</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Here <code>&lt;function_spec&gt;</code> is the CN specification of
<code>f</code>, a list of items of the following kind (and in that
order):</p>
<ul>
<li><p><code>trusted</code></p>
<p>To indicate that the function type should be trusted, not verified by
CN.</p></li>
<li><p><code>accesses [&lt;cn_variable&gt; (SEMICOLON &lt;cn_variable&gt;)*]</code></p>
<p>(<code>accesses</code> followed by a semicolon-separated list of one
or more variables) The list must only contain C global variables. The
specification <code>accesses VARS</code>, for some list of global
variables <code>VARS</code>, specifies that the functions takes (read
and write) ownership of <code>VARS</code> on entry, and returns
ownership of <code>VARS</code> at the end of its execution.</p>
<p><strong>Note:</strong> On function return, <code>VARS</code> are
permitted to have been assigned values different from their original
values; if the values are required to be unchanged, this can be
specified using additional <code>ensures</code> clauses.</p></li>
</ul>
<p>The <code>accesses</code> keyword provides a short-hand for
specifications that can also be expressed using <code>requires</code>
and <code>ensures</code> together with <code>Owned</code> (all of which
are described below).</p>
<ul>
<li><p><code>requires [&lt;condition&gt; (SEMICOLON &lt;condition&gt;)*]</code></p>
<p>(<code>requires</code> followed by a semicolon-separated list of one
or more CN conditions)</p>
<p><code>requires CONDS</code>, for a list <code>CONDS</code> of CN
conditions (explained below), specifies that <code>CONDS</code> have to
hold whenever the function is called.</p></li>
<li><p><code>ensures [&lt;condition&gt; (SEMICOLON &lt;condition&gt;)*]</code></p>
<p>(<code>ensures</code> followed by a semicolon-separated list of one
or more CN conditions)</p>
<p><code>ensures CONDS</code>, for a list of CN conditions
<code>CONDS</code> (explained below), specifies that <code>CONDS</code>
have to hold whenever the function returns.</p></li>
<li><p><code>function &lt;cn_variable&gt;</code></p></li>
</ul>
<p>(<code>function</code> followed by a variable name)</p>
<p>This instructs CN to automatically derive a CN specification
function, with the same name, from the annotated C function. Currently
this only works for relatively simple C functions.</p>
<h4 id="loop-types">Loop types</h4>
<p>In the case of loops, the CN type is given after the loop condition,
before the loop body block (currently only for and while loops are
supported):</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span><span class="op">(</span> <span class="op">...</span>loop condition<span class="op">...</span> <span class="op">)</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co">/*@ &lt;loop_spec&gt; @*/</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span>loop body<span class="op">...</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Here <code>&lt;loop_spec&gt;</code> is the CN loop invariant
specification, which must be of the form:</p>
<pre><code>inv [&lt;condition&gt; (SEMICOLON &lt;condition&gt;)*]</code></pre>
<p>(<code>inv</code> followed by a semicolon-separated list of one or
more CN conditions)</p>
<p><code>inv CONDS</code>, for a list of CN conditions
<code>CONDS</code> (explained below), specifies that <code>CONDS</code>
hold on loop entry (before the loop condition has been executed); hence
<code>CONDS</code> can be assumed to hold when the loop condition and
loop body are executed, and it has to be shown that their execution
re-establishes <code>CONDS</code>.</p>
<p><strong>Note:</strong> any global variables listed under
<code>accesses</code> in the surrounding function’s specification are
also considered “accessed” as part of the loop specification: CN
implicitly adds the corresponding ownership requirement into the loop
invariant.</p>
<h4 id="conditions">Conditions</h4>
<p>CN conditions, as used in function and loop type specifications,
include</p>
<ul>
<li>logical conditions,</li>
<li>ownership conditions, and</li>
<li>(for convenience) let bindings.</li>
</ul>
<p>These are defined in the following.</p>
<h5 id="logical-conditions">Logical conditions</h5>
<p>There are two forms of logical conditions:</p>
<ul>
<li><p><code>&lt;expr&gt;</code></p>
<p>(a boolean typed expression)</p>
<p>This simply asserts that the expression is required to evaluate to
<code>true</code>.</p></li>
<li><p><code>each LPAREN &lt;base_type&gt; &lt;cn_variable&gt; SEMICOLON &lt;expr&gt;                   RPAREN LBRACE &lt;expr&gt; RBRACE</code></p>
<p>Condition <code>each (BT V; C) { E }</code> introduces a new variable
<code>V</code>, of CN basetype <code>BT</code> (explained below) and
asserts that whenever <code>C</code> holds (for <code>V</code>),
<code>E</code> must also hold (for <code>V</code>).</p>
<p>For instance,
<code>each (i32 i; 0i32 &lt;= i &amp;&amp; i &lt; 10i32) { E }</code>
requires <code>E</code> to hold for all instances of <code>i</code>, of
basetype <code>i32</code>, when <code>i</code> is between <code>0</code>
and <code>10</code>.</p></li>
</ul>
<h5 id="ownership-conditions">Ownership conditions</h5>
<p>Users can specify ownership of memory using resources and ownership
conditions. A resource is a permission to manipulate an area of memory.
Similar to pointer ownership in Rust, this permission cannot be
duplicated; unlike Rust, in CN ownership also cannot be dropped. In CN,
resource predicates have <em>inputs</em> and <em>outputs</em>.
Informally, inputs are used to specify <em>what is owned</em>, while the
outputs are information that can be derived from the ownership, such as
the pointee value in the case of an owned pointer.</p>
<p><strong>Resource predicates.</strong> CN has three kinds of resource
predicates, the built-in predicates <code>Owned</code> and
<code>Block</code>, as well as user-defined predicates:</p>
<ul>
<li><p><code>Owned&lt;T&gt;</code>, for any C-type <code>T</code>.</p>
<p><code>Owned&lt;T&gt;</code> takes as input a pointer-expression. For
a given pointer expression <code>P</code>,
<code>Owned&lt;T&gt;(P)</code> asserts full (read and write) ownership
of memory at address <code>P</code>, at C-type <code>T</code>. Its
output is the memory value at address <code>P</code>.
<code>Owned&lt;T&gt;(P)</code> allows reading and writing
<code>P</code>, or any of its parts.</p></li>
<li><p><code>Block&lt;T&gt;</code> for any C-type <code>T</code>.</p>
<p><code>Block&lt;T&gt;</code> takes as input a pointer-expression. For
a given pointer expression <code>P</code>,
<code>Block&lt;T&gt;(P)</code> asserts ownership of memory at address
<code>P</code>, at C-type <code>T</code>; unlike <code>Owned</code>,
<code>Block</code> represents “uninitialised” memory, which can be
written but not read. The output of <code>Block</code> is
<code>void</code>.</p></li>
</ul>
<p>(Reading memory requires an <code>Owned</code> resource; writing
requires only a <code>Block</code> resource and returns an
<code>Owned</code> resource with updated value.) When the C-type
<code>T</code> of Owned and Block can be inferred by CN, the C-type
annotation <code>&lt;T&gt;</code> can be omitted.</p>
<ul>
<li>Aside from built-in resource predicates, users can also define new
resource predicates, as explained later. A resource definition includes
the definition of its inputs and outputs. The first input of a
user-defined resource predicate must always be the pointer the ownership
is associated with (just as in the case of <code>Owned</code> and
<code>Block</code>).</li>
</ul>
<p><strong>Ownership conditions.</strong> Ownership conditions are used
to specify resource ownership in function and loop type specifications.
They take the form</p>
<p><code>take &lt;cn_variable&gt; = &lt;resource&gt;</code></p>
<p>The condition <code>take V = RES</code> specifies that ownership of
resource <code>RES</code> is required; it also introduces a new variable
<code>V</code> and binds the outputs of resource <code>RES</code> to
<code>V</code>.</p>
<p>For instance <code>take x = Owned&lt;int&gt;(p)</code> specifies that
ownership of <code>int</code>-pointer <code>p</code> is required, and
binds the name <code>x</code> to the output of
<code>Owned&lt;int&gt;(p)</code>, so the pointee value of
<code>p</code>.</p>
<p>The resource is one of two kinds:</p>
<ul>
<li><p><code>&lt;pred&gt; LPAREN [&lt;expr&gt; (COMMA &lt;expr&gt;)*] RPAREN</code></p>
<p><code>Pred(ARGS)</code> asserts ownership of a resource predicate
<code>Pred</code> (one of the three possible kinds defined above)
applied to a list <code>ARGS</code> of one or more input expressions.
The output of this resource is as defined by the resource predicate
<code>Pred</code> (see above).</p></li>
<li><p><code>each LPAREN &lt;base_type&gt; &lt;cn_variable&gt; SEMICOLON &lt;expr&gt; RPAREN LBRACE &lt;pred&gt; LPAREN [&lt;expr&gt; (COMMA &lt;expr&gt;)*] RPAREN RBRACE</code></p>
<p>This is an iterated resource. Resource
<code>each (BT V; C) { Pred(ARGS) }</code> introduces a new (quantified)
variable <code>V</code> of basetype <code>BT</code> (explained below),
and asserts ownership of multiple instances of resource predicate
<code>Pred</code>: <code>Pred</code>, applied to arguments
<code>ARGS</code>, is owned for all instances of variable <code>V</code>
that satisfy condition <code>C</code>; typically both <code>C</code> and
<code>ARGS</code> will mention <code>V</code>.</p>
<p>For instance,
<code>each (i32 i; 0i32 &lt;= i &amp;&amp; i &lt; 10i32) { Owned&lt;int&gt;(array_shift&lt;int&gt;(p,i)) }</code>,
for an <code>int</code>-pointer <code>p</code>, requires ownership of an
<code>int</code>-array starting at <code>p</code>, for all indices up to
<code>10</code>. Here <code>array_shift&lt;T&gt;(P,I)</code>, for a
C-type <code>T</code>, pointer <code>P</code> (of arbitrary pointer
type), and index <code>I</code>, computes the pointer to the
<code>I</code>-th element of an array starting from <code>P</code>, at
type <code>T</code> (in the above example an
<code>int</code>-array).</p>
<p>The first input of an iterated resource, the pointer, must be an
expression of the shape <code>array_shift&lt;T&gt;(P,V)</code>, where
<code>T</code> is a C-type, <code>P</code> some pointer and
<code>V</code> the quantified variable. If <code>V</code> has basetype
<code>BT</code> and the output of the resource predicate <code>P</code>
is of basetype <code>OBT</code>, the iterated resource has an output of
type <code>map&lt;BT,OBT&gt;</code>, a map from indices into the array
(of quantifier basetype) to their output value (of basetype
<code>OBT</code>).</p></li>
</ul>
<h5 id="let-bindings">Let-bindings</h5>
<p>Finally, conditions also include let-bindings of the form</p>
<p><code>let &lt;cn_variable&gt; EQ &lt;expr&gt;</code></p>
<p><code>let V = E</code> defines variable <code>V</code> to be the
value of expression <code>E</code>.</p>
<h5 id="scoping">Scoping</h5>
<p>By default, in function specifications, global variables and the
function arguments are in scope. In <code>inv</code> loop invariant
specifications additionally the function’s local variables are in scope.
In <code>ensures</code> specifications the special <code>return</code>
variable is in scope, to refer to the functions return value.</p>
<p>Conditions can bring new variables into scope (i.e. ownership
conditions using <code>take</code>, and let-bindings). Within the body
of <code>requires</code>, <code>ensures</code>, or <code>inv</code>
their scoping follows the lexical structure. Moreover, variables bound
in the <code>requires</code> pre-condition are in scope for
<code>inv</code> loop invariants and for the <code>ensures</code>
post-condition. (While variables bound in <code>ensures</code> and
<code>inv</code> are not visible outside these.)</p>
<p>To make writing specifications more convenient, CN offers a
short-hand for referring to the pointee of an owned pointer. Where the
user has asserted <code>take V = Owned&lt;...&gt;(P)</code> for some
pointer expression <code>P</code> and variable <code>V</code>, they can
subsequently use the CN expression <code>*P</code> to refer to
<code>V</code>. This is a shallow surface-level feature –
<code>*P</code> can only be used if <code>Owned</code> has been asserted
for a term <em>syntactically</em> matching <code>P</code>, not merely
one that is provably the same as <code>P</code>. (Hence, following
condition <code>take V = Owned&lt;...&gt;(Q)</code>, CN will not allow
the user to specify <code>*P</code> in a subsequent condition, even if
<code>P==Q</code> is known.)</p>
<p>Since the user may include ownership of a pointer <code>P</code> both
in the <code>requires</code> and the <code>ensures</code> specification,
in principle the use of <code>*P</code> is ambiguous. CN uses the
following rules:</p>
<ul>
<li><p>A condition <code>take V = Owned&lt;...&gt;(P)</code> within a
<code>requires</code>/<code>ensures</code>/<code>inv</code>
specification brings <code>*P</code> only into scope for subsequent
conditions in the same
<code>requires</code>/<code>ensures</code>/<code>inv</code>
specification. For instance</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f<span class="op">(</span><span class="dt">int</span> <span class="op">*</span>p<span class="op">)</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="co">/*@ requires take x = Owned(p)</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co">    ensures *p == 0i32 </span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co">@*/</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>will lead to an error, because <code>*p</code> is not in scope in the
<code>ensures</code> specification.</p></li>
<li><p>Users can moreover use special syntax to “evaluate” expressions
using old pointee values, from the start of function execution:
<code>{E}@start</code> instructs CN to evaluate pointer-dereference
expressions (such as <code>*p</code>) using the initial pointee values
from the <code>requires</code> specification. For instance the marked
line in the example below asserts that the new value of <code>*p</code>
is the old value incremented by 1. (The expression <code>E</code> in
<code>{E}@start</code>, however, can freely combine
pointer-dereferencing with other terms into complex expressions.)</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f<span class="op">(</span><span class="dt">int</span> <span class="op">*</span>p<span class="op">)</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="co">/*@ requires take x = Owned(p)</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co">    ensures take y = Owned(p); </span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="co">            *p == {*p}@start + 1i32            // &lt;---</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="co">@*/</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
<li><p>A related short-hand is <code>{E} unchanged</code>, for the
common assertion that the value of expressions <code>E</code>, typically
involving pointer-dereferencing, is unchanged compare to the initial
state (e.g. the value is the same before and after execution of the
function, or is the same during the execution of the loop as in the
initial state).</p></li>
</ul>
<h4 id="basetypes">Basetypes</h4>
<p>CN’s base types include:</p>
<ul>
<li><code>void</code> (or <code>unit</code>)</li>
<li><code>bool</code></li>
<li>bounded integer types, such as <code>i32</code> and
<code>u8</code></li>
<li>unbounded mathematical integers, <code>integer</code> (hardly
used)</li>
<li>pointers, <code>pointer</code> (untyped in the pointee type)</li>
<li>pointer allocation IDs, <code>alloc_id</code> (for the in-progress
VIP memory model)</li>
<li>C structs, <code>struct T</code>, for struct tags
<code>T</code></li>
<li>user-defined inductive datatypes, <code>datatype T</code>, for a tag
<code>T</code></li>
<li>records/anonymous structs
<code>{ bt1 member1, ..., bt2 member2 }</code></li>
<li>maps, <code>map&lt;bt1,bt2&gt;</code>, for map domain
<code>bt1</code> and range <code>bt2</code></li>
<li>lists <code>list&lt;bt&gt;</code>, for a list element type
<code>bt</code></li>
<li>sets, <code>set&lt;bt&gt;</code>, for a set element type
<code>bt</code> (untested)</li>
</ul>
<h4 id="expressions-expr">Expressions (EXPR)</h4>
<p>CN has a C-like expression syntax. Expressions include</p>
<ul>
<li>C variables,</li>
<li>CN variables (such as let-bound variables and variables from
<code>take</code> ownership conditions)</li>
<li>pointer-dereferencing</li>
<li><code>{...}@start</code></li>
<li><code>{...}@unchanged</code></li>
<li>integer arithmetic and comparison</li>
<li>bit-wise arithmetic</li>
<li>pointer operations</li>
<li>boolean expressions</li>
<li>struct-value and struct-update expressions</li>
<li>map access and update operations</li>
</ul>
<h3 id="auxiliary-definitions">Auxiliary definitions</h3>
<p>CN top-level definitions and declarations are placed in the same
special comment syntax (<code>/*@ ... @*/</code>), at the global level
in C, that is, not attached to any C function or contained within any
enclosing C syntax.</p>
<p>These top-level commands mostly introduce new types and terms that
can be used in subsequent CN syntax. These declarations begin with an
identifying keyword (e.g. <code>datatype</code>,
<code>predicate</code>). Multiple such top-level commands can be placed
in the one special comment without any separator token, for
instance:</p>
<pre><code>/*@
datatype dt {
  ...
}

predicate (void) Pred (pointer p, i32 x) {
  ...
}
@*/</code></pre>
<h4 id="datatype-definitions">Datatype definitions</h4>
<p>The <code>datatype</code> top-level command adds a user-defined
datatype to the universe of CN base types.</p>
<p>For instance, the following definition introduces a list of 32-bit
integers (this will support different operations to CN’s builtin list
type).</p>
<pre><code>/*@
datatype int_list {
  Nil {},
  Cons {i32 hd, datatype int_list tl}
}
@*/</code></pre>
<p>The above introduces a two-constructor datatype. The new type can be
referred to with the syntax <code>int_list</code> or
<code>datatype int_list</code>.</p>
<p>The datatype syntax is designed to be similar to Rust’s, but not
necessarily the same.</p>
<p>Explicit values of the new datatype can be constructed with the
syntax
<code>&lt;cn_variable&gt; LBRACE &lt;member_def&gt;* RBRACE</code>,
e.g. <code>Cons {hd: 0i32, tl: Nil {}}</code>.</p>
<p>Values of the datatype can be destructed with the match syntax
<code>MATCH &lt;expr&gt; LBRACE &lt;match_case&gt;+ RBRACE</code>, where
each match case is of the form
<code>&lt;pattern&gt; EQ GT LBRACE &lt;expr&gt; RBRACE</code>. The
expression to be matched on must be parenthesised unless it is a single
token.</p>
<p>For instance, the sum of up to two elements of the list
<code>xs</code> can be written with:</p>
<pre><code>match xs {
  Nil {} =&gt; { 0i32 }
  Cons {hd : x1, tl: Nil {} } =&gt; { x1 }
  Cons {hd : x1, tl: Cons {hd : x2, tl: _ } } =&gt; { x1 + x2 }
}</code></pre>
<h4 id="specification-function-definitions">Specification function
definitions</h4>
<p>Users can define CN functions for use in specifications. Function
definitions can be recursive and mutually recursive. For instance, the
following defines a function computing the length of a list, using the
<code>int_list</code> datatype defined in the previous section.</p>
<pre><code>function [rec] (integer) length (datatype int_list l) {
  match l {
    Nil {} =&gt; { 0 }
    Cons { hd: _, tl: l2 } =&gt; { 1 + length(l2) }
  }
}</code></pre>
<p>This defines a function <code>length</code>, with a single argument,
<code>l</code> of <code>int_list</code> datatype, and with
<code>integer</code> return type.</p>
<p>Function definitions follow the form</p>
<pre><code>function &lt;cn_attrs&gt; LPAREN &lt;base_type&gt; RPAREN
  &lt;cn_variable&gt; LPAREN &lt;args&gt; RPAREN &lt;cn_option_func_body&gt;</code></pre>
<p>That is, <code>function</code> is followed by:</p>
<ul>
<li><p>an optional list of attributes<br />
(within square brackets, a comma-separated list of attribute
names),</p></li>
<li><p>the return basetype<br />
(enclosed in parentheses),</p></li>
<li><p>the name of the function,</p></li>
<li><p>the list of function arguments<br />
(within parentheses, a comma-separated list of arguments, each
comprising a basetype followed by the argument name),</p></li>
<li><p>an optional function body.</p></li>
</ul>
<p>The possible attributes are currently:</p>
<ul>
<li><p><code>rec</code>, to indicate a recursive function definition,
and</p></li>
<li><p><code>coq_unfold</code> {TODO}.</p></li>
</ul>
<p>The function body is simply an expression, enclosed in curly
braces.</p>
<p><strong>Functions without body.</strong> When the function body is
omitted, the function is treated as uninterpreted by CN: i.e. given the
definition of a function <code>f</code> without body, CN will not be
able to prove anything about <code>f(ARGS)</code> (the result of
applying <code>f</code> to some list of arguments <code>ARGS</code>),
other than deducing <code>f(ARGS) = f(ARGS&#39;)</code> from
<code>ARGS = ARGS&#39;</code> (for some other list of arguments
<code>ARGS&#39;</code>). Defining a CN function <code>f</code> without body
can be useful to treat <code>f</code> as abstract in the CN
verification, for instance when the goal is to deletate all proof
depending on the details of <code>f</code> to manual Coq proof.</p>
<p><strong>Recursive functions.</strong> In order to define a recursive
function, the attribute <code>rec</code> must be used. To define a
collection of two or more mutually recursive functions, simply use the
<code>rec</code> attribute for each of them.</p>
<p><strong>Note:</strong> Since verification becomes undecidable in the
presence of recursive specification functions, CN does not attempt to
reason about recursive definitions. Without explicit user intervention,
CN treats a function <code>f</code> with recursive (or mutually
recursive definition) the same as a function without body. When
verification of C code requires reasoning about such functions, users
have to manually assist in the proof, either by <em>manually unfolding
function definitions</em> or using <em>manually stated and applied
lemmata</em> (both of which are explained later).</p>
<h4 id="resource-predicate-definitions">Resource predicate
definitions</h4>
<p>In addition to the built-in resource predicates <code>Owned</code>
and <code>Block</code>, CN allows users to define new resource
predicates. This can be necessary to describe the ownership requirements
for the use of recursive datastructures, or useful for grouping together
common CN conditions under a single definition.</p>
<p>As explained earlier, in CN resources have inputs and outputs.
Informally, the inputs are arguments required to define <em>which memory
locations are owned</em>, whereas the outputs are information derived
from the inputs and the owned memory. In the case of the
<code>Owned</code> predicate, its single input is the pointer to the
owned memory location, its output is the pointee value stored in the
owned location. CN generalises this idea to arbitrary resource
predicates. In resource predicate definitions, the user therefore
decides which outputs a resource predicate should “expose”.</p>
<p>To illustrate resource predicate definitions, shown below is the CN
definition of a linked list data structure, which describes the
ownership shape associated with linked lists, here represented using the
C <code>struct list_head</code> type (of list elements).</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> list_head <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> v<span class="op">;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> list_head <span class="op">*</span>next<span class="op">;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Each element of the list is a <code>struct list_head</code>,
comprising an integer value <code>v</code>and pointer <code>next</code>,
to the next element of the list. A list is then represented as a
<code>struct list_head</code> pointer – using NULL to encode the empty
list, and a non-NULL pointer to the first/head element of a list stored
in memory for non-empty lists.</p>
<pre><code>/*@
predicate (datatype int_list) LinkedList (pointer p) {
  if (is_null(p)) {
    return Nil {};
  }
  else {
    take h = Owned&lt;struct list_head&gt;(p);
    take t = LinkedList(h.next);
    return Cons {hd: h.v, tl: t};
  }
}
@*/</code></pre>
<p>The CN definition encodes this informal description. The above CN
code defines a resource predicate <code>LinkedList</code>, which takes
the pointer <code>p</code>, the C encoding of the linked list, as an
input. Its output is a mathematical list, of datatype
<code>int_list</code> (as defined earlier above).</p>
<p>The body of <code>LinkedList</code> specifies what ownership of this
predicate means. This is usually done by distinguishing different cases,
using a top-level if-then-else structure. Each branch then specifies the
conditions required for the predicate to hold, using CN conditions as in
function and loop specifications, and ends in a return statement that
defines the predicate output for this branch.</p>
<p>Here there two cases:</p>
<ul>
<li><p>If <code>p</code> is the NULL pointer, then no memory ownership
is taken and no other conditions apply. The output, the mathematical
list represented by <code>p</code>, is the empty list, here specified
with <code>return Nil {}</code>.</p></li>
<li><p>Otherwise (for a non-NULL pointer <code>p</code>) the linked list
predicate requires ownership for <code>p</code>. The line
<code>take h = Owned&lt;struct list_head&gt;(p);</code> asserts this
ownership, at <code>struct list_head</code> type, and binds the value of
the owned struct to <code>h</code>. To specify ownership of the
remainder of the list the next line,
<code>take t = LinkedList(h.next);</code> claims ownership of another
instance of the <code>LinkedList</code> predicate, for the pointer
<code>h.next</code> to the next element of the list. This recursively
asserts ownership for the next element of the list, and all following
ones and returns the mathematical list representation for the remainder
of the list, binding this to <code>t</code>. (As in the case of function
and loop specifications, <code>h.next</code> can also be referred to
using the <code>*</code>-notation <code>(*p).next</code>; hence an
equivalent specification could have used the line
<code>take t = LinkedList((*p).next);</code>.) As in the first case, the
body of the else branch ends by defining the mathematical list output by
the predicate, here the cons of the the head value <code>h.v</code> and
the remainder of the list (returned from the recursive application of
LinkedList) <code>t</code>:
<code>return Cons {hd: h.v, tl: t}</code>.</p></li>
</ul>
<p>CN resource predicate definitions in general follow the same shape
shown in the linked list example:</p>
<pre><code>precicate &lt;cn_attrs&gt; &lt;cn_pred_output&gt; UNAME VARIABLE
         LPAREN &lt;args&gt; RPAREN &lt;cn_option_pred_clauses&gt;</code></pre>
<p>That is, <code>predicate</code>, followed by</p>
<ul>
<li><p>an optional list of attributes (currently none are used for
resource predicates);</p></li>
<li><p>the CN basetype of the predicate output;</p></li>
<li><p>the name of the resource predicate, by convention using uppercase
letters</p></li>
<li><p>a list of one or more predicate inputs (within parentheses, a
list of arguments, each being a CN basetype followed by the argument
name); the first argument is required to be the pointer the ownership is
associated with;</p></li>
<li><p>an optional predicate definition body.</p></li>
</ul>
<p>The (optional) predicate body is a collection of guarded
<code>clauses</code>, enclosed in curly braces; the <code>clauses</code>
have the form
<code>if ( &lt;EXPR&gt; ) { clause; } else { &lt;clauses&gt; }</code>,
where each clause is a semi-colon separated sequence of conditions
(<code>take</code> resource conditions, <code>assert</code> logical
conditions, <code>let</code> bindings) ending in a return statement for
the output. The return statement takes the expression being returned as
an output, or stands alone (with no argument) for returning
<code>void</code>/unit as an output.</p>
<pre><code>&lt;cn_option_pred_clauses&gt; ::= [LBRACE &lt;clauses&gt; RBRACE]

&lt;clauses&gt; ::= &lt;clause&gt; SEMICOLON
            | IF LPAREN &lt;expr&gt; RPAREN LBRACE &lt;clause&gt; SEMICOLON RBRACE ELSE
              LBRACE &lt;clauses&gt; RBRACE

&lt;clause&gt; ::= CN_TAKE &lt;cn_variable&gt; EQ &lt;resource&gt; SEMICOLON &lt;clause&gt;
           | CN_LET &lt;cn_variable&gt; EQ &lt;expr&gt; SEMICOLON &lt;clause&gt;
           | ASSERT LPAREN &lt;assert_expr&gt; RPAREN SEMICOLON &lt;clause&gt;
           | RETURN &lt;expr&gt;
           | RETURN</code></pre>
<h3 id="proof-assistance">Proof assistance</h3>
<h4 id="cn-statements">CN statements</h4>
<h4 id="lemma-statements">Lemma statements</h4>
<h2 id="grammar">Grammar</h2>
<pre><code>&lt;prim_expr&gt; ::= CN_NULL
              | CN_TRUE
              | CN_FALSE
              | CONSTANT
              | CN_CONSTANT
              | &lt;cn_variable&gt;
              | RETURN
              | &lt;prim_expr&gt; DOT &lt;cn_variable&gt;
              | LPAREN &lt;expr&gt; RPAREN
              | CN_ARRAY_SHIFT LT &lt;ctype&gt; GT LPAREN &lt;expr&gt; COMMA &lt;expr&gt;
                RPAREN
              | CN_ARRAY_SHIFT LPAREN &lt;expr&gt; COMMA &lt;expr&gt; RPAREN
              | CN_MEMBER_SHIFT LPAREN &lt;expr&gt; COMMA &lt;cn_variable&gt; RPAREN
              | CN_MEMBER_SHIFT LT &lt;cn_variable&gt; GT LPAREN &lt;expr&gt; COMMA
                &lt;cn_variable&gt; RPAREN
              | &lt;cn_variable&gt; LPAREN [&lt;expr&gt; (COMMA &lt;expr&gt;)*] RPAREN
              | &lt;cn_good&gt; LPAREN &lt;expr&gt; RPAREN
              | &lt;cn_variable&gt; &lt;cons_args&gt;
              | &lt;prim_expr&gt; LBRACK &lt;expr&gt; RBRACK
              | LBRACE &lt;expr&gt; RBRACE PERCENT &lt;NAME&gt; VARIABLE
              | LBRACE &lt;record_def&gt; RBRACE
              | LBRACE &lt;nonempty_member_updates&gt; RBRACE
              | &lt;prim_expr&gt; LBRACK &lt;index_update&gt; (COMMA &lt;index_update&gt;)*
                RBRACK

&lt;unary_expr&gt; ::= &lt;prim_expr&gt;
               | STAR &lt;unary_expr&gt;
               | SIZEOF LT &lt;ctype&gt; GT
               | OFFSETOF LPAREN &lt;cn_variable&gt; COMMA &lt;cn_variable&gt; RPAREN
               | LBRACE &lt;expr&gt; RBRACE CN_UNCHANGED
               | BANG &lt;prim_expr&gt;
               | AMPERSAND LPAREN &lt;prim_expr&gt; MINUS_GT &lt;cn_variable&gt; RPAREN
               | AMPERSAND &lt;cn_variable&gt;
               | LPAREN &lt;base_type_explicit&gt; RPAREN &lt;prim_expr&gt;

&lt;mul_expr&gt; ::= &lt;unary_expr&gt;
             | &lt;mul_expr&gt; STAR &lt;unary_expr&gt;
             | &lt;mul_expr&gt; SLASH &lt;unary_expr&gt;

&lt;add_expr&gt; ::= &lt;mul_expr&gt;
             | &lt;add_expr&gt; PLUS &lt;mul_expr&gt;
             | &lt;add_expr&gt; MINUS &lt;mul_expr&gt;

&lt;rel_expr&gt; ::= &lt;add_expr&gt;
             | &lt;rel_expr&gt; EQ_EQ &lt;add_expr&gt;
             | &lt;rel_expr&gt; BANG_EQ &lt;add_expr&gt;
             | &lt;rel_expr&gt; LT &lt;add_expr&gt;
             | &lt;rel_expr&gt; GT &lt;add_expr&gt;
             | &lt;rel_expr&gt; LT_EQ &lt;add_expr&gt;
             | &lt;rel_expr&gt; GT_EQ &lt;add_expr&gt;

&lt;bool_bin_expr&gt; ::= &lt;rel_expr&gt;
                  | &lt;bool_bin_expr&gt; AMPERSAND_AMPERSAND &lt;rel_expr&gt;
                  | &lt;bool_bin_expr&gt; PIPE_PIPE &lt;rel_expr&gt;

&lt;list_expr&gt; ::= &lt;bool_bin_expr&gt;
              | LBRACK &lt;rel_expr&gt; (COMMA &lt;rel_expr&gt;)* RBRACK

&lt;int_range&gt; ::= CONSTANT COMMA CONSTANT

&lt;member_def&gt; ::= &lt;cn_variable&gt; COLON &lt;expr&gt;

&lt;member_updates&gt; ::= &lt;member_def&gt; COMMA &lt;member_updates&gt;
                   | DOT DOT &lt;expr&gt;

&lt;nonempty_member_updates&gt; ::= &lt;member_def&gt; COMMA &lt;member_updates&gt;

&lt;index_update&gt; ::= &lt;prim_expr&gt; COLON &lt;expr&gt;

&lt;match_cases&gt; ::= &lt;match_case&gt;+

&lt;pattern_member_def&gt; ::= &lt;cn_variable&gt; COLON &lt;pattern&gt;

&lt;pattern_cons_args&gt; ::= LBRACE [&lt;pattern_member_def&gt; (COMMA
                        &lt;pattern_member_def&gt;)*] RBRACE

&lt;pattern&gt; ::= CN_WILD
            | &lt;cn_variable&gt;
            | &lt;cn_variable&gt; &lt;pattern_cons_args&gt;

&lt;match_case&gt; ::= &lt;pattern&gt; EQ GT LBRACE &lt;expr&gt; RBRACE

&lt;match_target&gt; ::= &lt;cn_variable&gt;
                 | LPAREN &lt;expr&gt; RPAREN

&lt;expr_without_let&gt; ::= &lt;list_expr&gt;
                     | &lt;list_expr&gt; QUESTION &lt;list_expr&gt; COLON &lt;list_expr&gt;
                     | IF LPAREN &lt;expr&gt; RPAREN LBRACE &lt;expr&gt; RBRACE ELSE
                       LBRACE &lt;expr&gt; RBRACE
                     | CN_EACH LPAREN &lt;base_type&gt; &lt;cn_variable&gt; COLON
                       &lt;int_range&gt; SEMICOLON &lt;expr&gt; RPAREN
                     | CN_MATCH &lt;match_target&gt; LBRACE &lt;match_cases&gt; RBRACE

&lt;expr&gt; ::= &lt;expr_without_let&gt;
         | CN_LET &lt;cn_variable&gt; EQ &lt;expr&gt; SEMICOLON &lt;expr&gt;

&lt;base_type_explicit&gt; ::= VOID
                       | CN_BOOL
                       | CN_INTEGER
                       | CN_BITS
                       | CN_REAL
                       | CN_POINTER
                       | CN_ALLOC_ID
                       | LBRACE &lt;nonempty_args&gt; RBRACE
                       | STRUCT &lt;cn_variable&gt;
                       | CN_DATATYPE &lt;cn_variable&gt;
                       | CN_MAP LT &lt;base_type&gt; COMMA &lt;base_type&gt; GT
                       | CN_LIST LT &lt;base_type&gt; GT
                       | CN_TUPLE LT [&lt;base_type&gt; (COMMA &lt;base_type&gt;)*] GT
                       | CN_SET LT &lt;base_type&gt; GT

&lt;base_type&gt; ::= &lt;base_type_explicit&gt;
              | &lt;cn_variable&gt;

&lt;cn_good&gt; ::= CN_GOOD LT &lt;ctype&gt; GT

&lt;cn_option_pred_clauses&gt; ::= [LBRACE &lt;clauses&gt; RBRACE]

&lt;cn_cons_case&gt; ::= &lt;cn_variable&gt; LBRACE &lt;args&gt; RBRACE

&lt;cn_cons_cases&gt; ::= [&lt;cn_cons_case&gt; (COMMA &lt;cn_cons_case&gt;)*]

&lt;cn_attrs&gt; ::= [LBRACK [&lt;cn_variable&gt; (COMMA &lt;cn_variable&gt;)*] RBRACK]

&lt;cn_function&gt; ::= CN_FUNCTION &lt;cn_attrs&gt; LPAREN &lt;base_type&gt; RPAREN
                  &lt;cn_variable&gt; LPAREN &lt;args&gt; RPAREN &lt;cn_option_func_body&gt;

&lt;cn_predicate&gt; ::= CN_PREDICATE &lt;cn_attrs&gt; &lt;cn_pred_output&gt; UNAME VARIABLE
                   LPAREN &lt;args&gt; RPAREN &lt;cn_option_pred_clauses&gt;

&lt;cn_lemma&gt; ::= CN_LEMMA &lt;cn_variable&gt; LPAREN &lt;args&gt; RPAREN CN_REQUIRES
               &lt;condition&gt; (SEMICOLON &lt;condition&gt;)* CN_ENSURES &lt;condition&gt;
               (SEMICOLON &lt;condition&gt;)*

&lt;cn_datatype&gt; ::= CN_DATATYPE &lt;cn_variable&gt; LBRACE &lt;cn_cons_cases&gt; RBRACE

&lt;cn_fun_spec&gt; ::= CN_SPEC &lt;cn_variable&gt; LPAREN &lt;args&gt; RPAREN CN_REQUIRES
                  &lt;condition&gt; (SEMICOLON &lt;condition&gt;)* CN_ENSURES &lt;condition&gt;
                  (SEMICOLON &lt;condition&gt;)*

&lt;cn_type_synonym&gt; ::= CN_TYPE_SYNONYM &lt;cn_variable&gt; EQ
                      &lt;opt_paren(&lt;base_type&gt;)&gt;

&lt;cn_variable&gt; ::= &lt;NAME&gt; VARIABLE
                | &lt;NAME&gt; TYPE

&lt;args&gt; ::= [&lt;base_type&gt; &lt;cn_variable&gt; (COMMA &lt;base_type&gt; &lt;cn_variable&gt;)*]

&lt;nonempty_args&gt; ::= (&lt;base_type&gt; &lt;cn_variable&gt; (COMMA &lt;base_type&gt;
                    &lt;cn_variable&gt;)*)

&lt;opt_paren(A)&gt; ::= A
                 | LPAREN A RPAREN

&lt;cn_pred_output&gt; ::= &lt;opt_paren(&lt;base_type&gt;)&gt;

&lt;record_def&gt; ::= &lt;member_def&gt; (COMMA &lt;member_def&gt;)*

&lt;cons_args&gt; ::= LBRACE [&lt;member_def&gt; (COMMA &lt;member_def&gt;)*] RBRACE

&lt;clauses&gt; ::= &lt;clause&gt; SEMICOLON
            | IF LPAREN &lt;expr&gt; RPAREN LBRACE &lt;clause&gt; SEMICOLON RBRACE ELSE
              LBRACE &lt;clauses&gt; RBRACE

&lt;cn_option_func_body&gt; ::= [LBRACE &lt;expr&gt; RBRACE]

&lt;clause&gt; ::= CN_TAKE &lt;cn_variable&gt; EQ &lt;resource&gt; SEMICOLON &lt;clause&gt;
           | CN_LET &lt;cn_variable&gt; EQ &lt;expr&gt; SEMICOLON &lt;clause&gt;
           | ASSERT LPAREN &lt;assert_expr&gt; RPAREN SEMICOLON &lt;clause&gt;
           | RETURN &lt;expr&gt;
           | RETURN

&lt;assert_expr&gt; ::= CN_EACH LPAREN &lt;base_type&gt; &lt;cn_variable&gt; SEMICOLON &lt;expr&gt;
                  RPAREN LBRACE &lt;expr&gt; RBRACE
                | &lt;expr_without_let&gt;

&lt;resource&gt; ::= &lt;pred&gt; LPAREN [&lt;expr&gt; (COMMA &lt;expr&gt;)*] RPAREN
             | CN_EACH LPAREN &lt;base_type&gt; &lt;cn_variable&gt; SEMICOLON &lt;expr&gt;
               RPAREN LBRACE &lt;pred&gt; LPAREN [&lt;expr&gt; (COMMA &lt;expr&gt;)*] RPAREN
               RBRACE

&lt;pred&gt; ::= CN_OWNED LT &lt;ctype&gt; GT
         | CN_OWNED
         | CN_BLOCK LT &lt;ctype&gt; GT
         | UNAME VARIABLE

&lt;ctype&gt; ::= &lt;type_name&gt;

&lt;condition&gt; ::= CN_TAKE &lt;cn_variable&gt; EQ &lt;resource&gt;
              | CN_LET &lt;cn_variable&gt; EQ &lt;expr&gt;
              | &lt;assert_expr&gt;

&lt;function_spec_item&gt; ::= CN_TRUSTED
                       | CN_ACCESSES [&lt;cn_variable&gt; (SEMICOLON
                         &lt;cn_variable&gt;)*]
                       | CN_REQUIRES [&lt;condition&gt; (SEMICOLON &lt;condition&gt;)*]
                       | CN_ENSURES [&lt;condition&gt; (SEMICOLON &lt;condition&gt;)*]
                       | CN_FUNCTION &lt;cn_variable&gt;

&lt;function_spec&gt; ::= &lt;function_spec_item&gt;* EOF

&lt;loop_spec&gt; ::= CN_INV [&lt;condition&gt; (SEMICOLON &lt;condition&gt;)*] EOF

&lt;to_be_instantiated&gt; ::= epsilon
                       | &lt;cn_variable&gt; COMMA
                       | &lt;cn_good&gt; COMMA

&lt;to_be_extracted&gt; ::= [&lt;pred&gt; COMMA]

&lt;cn_statement&gt; ::= CN_PACK &lt;pred&gt; LPAREN [&lt;expr&gt; (COMMA &lt;expr&gt;)*] RPAREN
                   SEMICOLON
                 | CN_UNPACK &lt;pred&gt; LPAREN [&lt;expr&gt; (COMMA &lt;expr&gt;)*] RPAREN
                   SEMICOLON
                 | CN_HAVE &lt;assert_expr&gt; SEMICOLON
                 | CN_EXTRACT &lt;to_be_extracted&gt; &lt;expr&gt; SEMICOLON
                 | CN_INSTANTIATE &lt;to_be_instantiated&gt; &lt;expr&gt; SEMICOLON
                 | CN_SPLIT_CASE &lt;assert_expr&gt; SEMICOLON
                 | CN_UNFOLD &lt;cn_variable&gt; LPAREN [&lt;expr&gt; (COMMA &lt;expr&gt;)*]
                   RPAREN SEMICOLON
                 | CN_APPLY &lt;cn_variable&gt; LPAREN [&lt;expr&gt; (COMMA &lt;expr&gt;)*]
                   RPAREN SEMICOLON
                 | ASSERT LPAREN &lt;assert_expr&gt; RPAREN SEMICOLON
                 | INLINE [&lt;cn_variable&gt; (COMMA &lt;cn_variable&gt;)*] SEMICOLON
                 | CN_PRINT LPAREN &lt;expr&gt; RPAREN SEMICOLON

&lt;cn_toplevel_elem&gt; ::= &lt;cn_predicate&gt;
                     | &lt;cn_function&gt;
                     | &lt;cn_lemma&gt;
                     | &lt;cn_datatype&gt;
                     | &lt;cn_type_synonym&gt;
                     | &lt;cn_fun_spec&gt;

&lt;cn_toplevel&gt; ::= EOF
                | &lt;cn_toplevel_elem&gt; &lt;cn_toplevel&gt;

</code></pre>
</body>
</html>
